<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jaco</title>
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --text-color: #1f2937;
            --bg-color: #f3f4f6;
            --input-bg: #ffffff;
            --border-color: #e5e7eb;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            min-height: 100vh;
        }

        @font-face {
            font-family: "JacoMaru";
            src: url("https://hajaulee.github.io/Houf-Jaco-Maru/new_fonts/ttf/HoufJacoMaru-Light.ttf");
        }

        @font-face {
            font-family: "HoufRegular";
            src: url("https://hajaulee.github.io/Houf-Jaco-Regular-Script/new_fonts/ttf/HoufRegularScript-Light.ttf");
        }

        @font-face {
            font-family: "HoufFaze";
            src: url("https://hajaulee.github.io/Houf-Jaco-Faze/new_fonts/ttf/HoufFaze.ttf");
        }

        @font-face {
            font-family: "sanjikaishu";
            src: url("./fonts/SanJiKaiShu-2.ttf");
        }

        @font-face {
            font-family: "bianyakai";
            src: url("./fonts/AaBianYaKai-2.ttf");
        }

        .jaco-maru-font {
            font-family: 'JacoMaru', Courier, monospace !important;
        }

        .regular-font {
            font-family: 'HoufRegular', 'sanjikaishu', Courier, monospace !important;
        }

        .faze-font {
            font-family: 'HoufFaze', 'bianyakai', Courier, monospace !important;
        }

        .input-text {
            outline: none;
            width: 100%;
            min-height: 300px;
            max-width: 800px;
            height: calc(100vh - 200px);
            border-radius: 12px;
            padding: 1.5em;
            margin: 1.5em auto;
            font-size: 16px;
            border: 1px solid var(--border-color);
            background: var(--input-bg);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .input-text:focus {
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.15);
            border-color: var(--primary-color);
        }

        .center {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 1rem;
        }

        .w3-bar {
            position: sticky;
            top: 0;
            z-index: 1;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            padding: 0.5rem 0;
        }

        .w3-bar-item {
            transition: background-color 0.3s ease;
            border-radius: 6px;
            margin: 0 4px;
            color: #fff !important;
        }

        .w3-bar-item:hover {
            background-color: rgba(255, 255, 255, 0.1) !important;
        }

        .w3-bar-item.w3-red {
            background-color: rgba(255, 255, 255, 0.2) !important;
            color: #ff0 !important;
        }
        
        
        #textOutput {
            font-size: 24px;
            line-break: anywhere;
            margin: 0 auto;
            width: fit-content;
            /* display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; */
            min-height: calc(100vh - 300px);
        }

        #textOutput h1, h2, h3, h4, h5, h6 {
            font-family: inherit;
        }

        #textOutput h1 {
            font-size: 56px;
        }

        #textOutput.vertical-lr .page {
            writing-mode: vertical-lr;
            padding-left: 6em;
        }

        #textOutput.vertical-rl .page {
            writing-mode: vertical-rl;
            padding-right: 6em;
        }

        #textOutput.lr .page {
            writing-mode: horizontal-tb;
            padding-right: 3em;
            padding-left: 6em;
        }

        .page {
            width: 35em;
            height: 49em;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1em;
            letter-spacing: 0.1rem;
            padding-top: 3em;
            position: relative;
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .pageNum {
            position: absolute;
            bottom: 5px;
            left: 0;
            writing-mode: lr;
            width: 100%;
            display: flex;
            justify-content: center;
        }

        rt {
            user-select: none; /* Disable text selection */
            -webkit-user-select: none;  /* Safari */
            -ms-user-select: none;      /* IE/Edge */
        }

        .controls-panel {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            margin: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 1rem;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        select, input[type="number"] {
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--input-bg);
            min-width: 120px;
            font-size: 14px;
        }

        input[type="checkbox"] {
            width: 1.2rem;
            height: 1.2rem;
            border-radius: 4px;
            accent-color: var(--primary-color);
        }

        button#pdfExportBtn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s ease;
        }

        button#pdfExportBtn:hover {
            background-color: var(--secondary-color);
        }

        @media print {
            body {
                visibility: hidden;
            }
            #textOutput {
                visibility: visible;
                position: absolute;
                left: 0;
                top: 0;
            }

            #textOutput .page{
                border: none;
                box-shadow: none;
            }

            #textOuput hr {
                visibility: hidden;
                display: none;
            }
        }
    </style>
    <script src="../extension/converter.js"></script>
</head>

<body>
    <div class="w3-container">
        <div class="w3-bar">
            <button class="w3-bar-item w3-button tablink w3-red" onclick="openTab(event,'Viet')">Tiếng Việt</button>
            <button class="w3-bar-item w3-button tablink" onclick="openTab(event,'Jaco')">Jaco</button>
            <button class="w3-bar-item w3-button tablink"><a style="color: white; text-decoration: none;" target="_blank" href="https://github.com/hajaulee/jaco">Github</a></button>
        </div>

        <div id="Viet" class="w3-container tab-content w3-animate-left">
            <div class="center">
                <textarea id="textInput" class="input-text" placeholder="Nhập văn bản ở đây!"></textarea>
            </div>
        </div>

        <div id="Jaco" class="w3-container tab-content w3-animate-right" style="display:none">
            <div class="controls-panel">
                <div class="control-group">
                    <div class="control-item">
                        <input type="checkbox" id="useHantuCheckBox">
                        <label for="useHantuCheckBox">Dùng chữ Hán</label>
                    </div>
                    <div class="control-item">
                        <input type="checkbox" id="useChuamCheckBox">
                        <label for="useChuamCheckBox">Ghi chú âm</label>
                    </div>
                    <div class="control-item">
                        <label for="fontSelect">Phông chữ</label>
                        <select id="fontSelect">
                            <option value="jaco-maru-font">Jaco Maru</option>
                            <option value="regular-font">Regular</option>
                            <option value="faze-font">Faze</option>
                        </select>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-item">
                        <label for="lineInPage">Số dòng trong trang</label>
                        <input type="number" id="lineInPage" value="16" min="1" max="100" />
                    </div>
                    <div class="control-item">
                        <label for="charInLine">Số ký tự trong dòng</label>
                        <input type="number" id="charInLine" value="35" min="1" max="100" />
                    </div>
                    <div class="control-item">
                        <label for="writingMode">Hướng chữ</label>
                        <select id="writingMode">
                            <option value="vertical-rl" selected>Dọc, phải sang trái</option>
                            <option value="vertical-lr">Dọc, trái sang phải</option>
                            <option value="lr">Ngang, trái sang phải</option>
                        </select>
                    </div>
                    <button id="pdfExportBtn" onclick="window.print();">Xuất PDF</button>
                </div>
            </div>
            <div id="textOutput" class="jaco-maru-font vertical-rl">Hello</div>
        </div>

        <div id="htmlUnescaper" style="display: none;"></div>
    </div>

    <script>
        function openTab(evt, tabName) {
            var i, x, tablinks;
            x = document.getElementsByClassName("tab-content");
            for (i = 0; i < x.length; i++) {
                x[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tablink");
            for (i = 0; i < x.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" w3-red", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " w3-red";
        }
    </script>
    <script>
        const fullWidthMap = {
            ",": "、",
            ".": "。"
        };
        const S_HANTU = "［ｈａｎｔｕ；"
        const E_HANTU = "ｈａｎｔｕ；］"
        const S_CHUAM = "［ｃｈｕａｍ；"
        const E_CHUAM = "ｃｈｕａｍ；］"

        const tagDict = {
            "＜ｈ１＞": '<h1>',
            "＜／ｈ１＞": '</h1>',
            "＜ｈ２＞": '<h2>',
            "＜／ｈ２＞": '</h2>',
            "、 ": "、",
            "。 ": "。",
            [S_HANTU]: '<ruby>',
            [E_HANTU]: "</ruby>",
            [S_CHUAM]: "<rt>",
            [E_CHUAM]: "</rt>"
        };

        let gLineInPage = 16;
        let gCharInLine = 35;

        function toFullWidthString(s) {
            return s
                .replace(new RegExp(Object.keys(fullWidthMap).join("|"), 'g'), mt => fullWidthMap[mt] || mt)
                .replace(/[!-~]/g, fullwidthChar => String.fromCharCode(fullwidthChar.charCodeAt(0) + 0xfee0))
                .replace(/＂([^＂]+)＂/g, '「$1」');
        }
        function toHalfWidthString(s) {
            return s.replace(/[！-～]/g, halfwidthChar => String.fromCharCode(halfwidthChar.charCodeAt(0) - 0xfee0));
        }
        function fixHalfwidth(s) {
            return s.replace(/＆＃[０-９]+；/g, mt => toHalfWidthString(mt));
        }

        function fixPageContent(s) {
            return replaceWithDictionary(s, tagDict);
        }

        function replaceWithDictionary(str, dict) {
            const regex = new RegExp(Object.keys(dict).join("|"), "g");
            return str.replace(regex, (match) => dict[match] || match);
        }

        function chunkArray(array, size) {
            const chunks = [];
            array = Array.from(array);
            for (let i = 0; i < array.length; i += size) {
                chunks.push(array.slice(i, i + size));
            }
            return chunks;
        }

        function chunkLine(str, size) {
            
            // Remove all halfwidth space
            str = str.replace(/ /g, '')
            let array = Array.from(str);
            
            const chunks = [];
            const tagLengthMap = Object.keys(tagDict).reduce((dict, key) => {
                dict[key] = Array.from(key).length;
                return dict;
            }, {});
            const tagNames = Object.keys(tagDict);
            const longestTag = Math.max(...tagNames.map(tag => tagLengthMap[tag]));

            let i = 0;
            let sliced = [];
            let tagsInSlice = [];
            let tagsIndexesInSlice = [];
            while (i < array.length){
                let lookAhead = size;

                while (i + lookAhead < array.length + size){
                    let sliced = array.slice(i, i + lookAhead);
                    const slicedString = sliced.join('');
                    [tagsInSlice, tagsIndexesInSlice] = findKeysInText(slicedString, tagNames);

                    // Index in string not same index in array, because array element is char, string element is byte
                    tagsIndexesInSlice = tagsIndexesInSlice.map((_index) => Array.from(slicedString.slice(0, _index)).length);
                    
                    const totalTagCharCount = sumOf(tagsInSlice.map(tag => tagLengthMap[tag]));
                    // Simple case chuam has 1 letter. TODO: case chuam multi letters
                    const totalOfChuam = findAllIndexes(tagsInSlice, S_CHUAM).length;
                    
                    if (sliced.length - totalTagCharCount - totalOfChuam >= size + longestTag){
                        break;
                    }
                    lookAhead += size;
                }

                // Simple case chuam has 1 letter. TODO: case chuam multi letters
                const ranges = tagsInSlice.map((tag, _index) => [tagsIndexesInSlice[_index], tag == S_CHUAM ? tagLengthMap[tag] + 1 : tagLengthMap[tag]]);
                
                const binaryArray = createBinaryArray(ranges, lookAhead);
                const fitSize = findCumsumIndex(binaryArray, size) + 1;
                
                sliced = array.slice(i, i + fitSize);
                [tagsInSlice, tagsIndexesInSlice] = findKeysInText(sliced.join(''), tagNames);

                // Add hantu open/close tag when break middle ruby tag
                const hantuOpenIndexes = findAllIndexes(tagsInSlice, S_HANTU);
                const hantuCloseIndexes = findAllIndexes(tagsInSlice, E_HANTU);
                
                if (hantuOpenIndexes.length > hantuCloseIndexes.length){
                    // Miss close tag
                    sliced = sliced.concat(Array.from(E_HANTU));
                } else if (hantuOpenIndexes.length < hantuCloseIndexes.length) {
                    // Miss open tag
                    sliced = Array.from(S_HANTU).concat(sliced);
                } else if (hantuCloseIndexes.length > 0 && hantuOpenIndexes[0] > hantuCloseIndexes[0]){
                    // Miss open tag and close tag
                    sliced = Array.from(S_HANTU).concat(sliced).concat(Array.from(E_HANTU));
                }

                chunks.push(sliced);
                i += fitSize;
                
            }
            
            return chunks;
        }

        function sumOf(params) {
            return params.reduce((acc, it) => acc + it, 0);
        }

        function createBinaryArray(ranges, size) {
            let arr = new Array(size).fill(1);
            
            for (let [start, length] of ranges) {
                for (let i = start; i < start + length && i < size; i++) {
                    arr[i] = 0;
                }
            }
            return arr;
        }

        function findCumsumIndex(arr, n) {
            let sum = 0;
            let index = -1;
            for (let i = 0; i < arr.length; i++) {
                sum += arr[i];
                if (sum == n) {
                    index = i;
                }
            }
            return index !== -1 ? index: arr.length;
        }

        function findKeysInText(text, keys) {
            const foundResults = [];
            keys.forEach(key => {
                findAllIndexes(text, key).forEach(index => {
                    foundResults.push({key, index});
                });
            });

            // Sort based on index
            foundResults.sort((a, b) => a.index - b.index);

            // Extract sorted values
            const foundKeys = foundResults.map(item => item.key);
            const foundIndexes = foundResults.map(item => item.index);

            return [foundKeys, foundIndexes];
        }

        function findAllIndexes(arr, value) {
            let indexes = [];
            let i = arr.indexOf(value);
        
            while (i !== -1) {
                indexes.push(i);
                i = arr.indexOf(value, i + 1); // search for next occurrence
            }

            return indexes;
        }

        function unescapeHTML(html) {
            div = htmlUnescaper;
            div.innerHTML = html;
            return ("innerText" in div) ? div.innerText : div.textContent; // IE | FF
        }

        function paging(s){
            // Assume h1 get 3 lines, h2 get 2 line.
            s = s
                .replaceAll("＜／ｈ１＞", '＜／ｈ１＞\n\n\n\n\n\n')
                .replaceAll("＜／ｈ２＞", '＜／ｈ２＞\n\n\n\n')
            const lines = s.split("\n\n"); // Empty line in source as new line
            const cuttedLines = [];
            for (let line of lines){
                line = unescapeHTML(line);
                line = line.replace(/\n/g, ''); // Remove single line
                let chunkedLines = chunkLine(line, gCharInLine).map(chars => chars.join(''));
                if (chunkedLines.length == 0){
                    chunkedLines = [line];
                }
                cuttedLines.push(...chunkedLines);
            }
            
            const pages = chunkArray(cuttedLines, gLineInPage).map(lines => lines
                .map(line => line.trim())
                .join("<br>")
                .replaceAll("＜／ｈ１＞<br><br>", "＜／ｈ１＞")
                .replaceAll("＜／ｈ２＞<br>", "＜／ｈ２＞")
            );
            
            return pages
        }



        const conveter = new Converter();
        const codeMapFetching = fetch("../extension/code_map.json").then(res => res.json());
        const hanvietFetching = fetch("../extension/hanviet_dict.json").then(res => res.json());
        const chuamFetching = fetch("../extension/chuam_dict.json").then(res => res.json());
        Promise.all([codeMapFetching, hanvietFetching, chuamFetching]).then(values => {
            conveter.updateResources(values[0], values[1], values[2]);
        });

        const textInput = document.getElementById("textInput");
        const textOutput = document.getElementById("textOutput");
        const useHantuCheckBox = document.getElementById("useHantuCheckBox");
        const useChuamCheckBox = document.getElementById("useChuamCheckBox");
        const fontSelect = document.getElementById("fontSelect");
        const lineInPageInput = document.getElementById("lineInPage");
        const charInLineInput = document.getElementById("charInLine");
        const writingModeSelect = document.getElementById("writingMode");


        async function convertInput() {
            localStorage.setItem('inputText', textInput.value);
            // Load cache from sessionStorage
            conveter.cache = JSON.parse(sessionStorage.getItem('jaco:cache') || '{}');
            conveter.useChuam = useChuamCheckBox.checked;
            const rawConvertedText = await conveter.convertAsync(textInput.value, useHantuCheckBox.checked);
            const convertedText = fixHalfwidth(toFullWidthString(rawConvertedText));
            const pages = paging(convertedText);
            const pageTemplate = "<div class='page'>$pageContent<div class='pageNum'>$pageNum</div></div>";
            const startPage = 1;
            textOutput.innerHTML = pages.map((page, index) => {
                return pageTemplate
                    .replace("$pageContent", fixPageContent(page))
                    .replace("$pageNum", index + startPage)
            }).join('');
            textOutput.innerHTML += `<div><img src="../docs/rule-1.svg" style="width: 35em;"></div>`;
            textOutput.innerHTML += `<div><img src="../docs/rule-2.svg" style="width: 35em;"></div>`;

            // Save cache to sessionStorage
            sessionStorage.setItem('jaco:cache', JSON.stringify(conveter.cache));
        }

        textInput.addEventListener('keyup', () => convertInput());
        textInput.addEventListener('change', () => convertInput());
        useHantuCheckBox.addEventListener('change', () => convertInput());
        useChuamCheckBox.addEventListener('change', () => convertInput());
        conveter.ready.then(() => {
            textInput.value = localStorage.getItem('inputText') || 'Xin chào 越南 from Z。'
            convertInput();
        });
        fontSelect.addEventListener('change', () => {
            const selectedFont = fontSelect.value;
            textOutput.classList.remove("jaco-maru-font", "regular-font", "faze-font");
            textOutput.classList.add(selectedFont);
        });
        lineInPageInput.addEventListener('change', () => {
            gLineInPage = parseInt(lineInPageInput.value);
            convertInput();
        });
        charInLineInput.addEventListener('change', () => {
            gCharInLine = parseInt(charInLineInput.value);
            convertInput();
        });
        writingModeSelect.addEventListener('change', () => {
            const mode = writingModeSelect.value;
            textOutput.classList.remove("vertical-rl", "vertical-lr", "lr");
            textOutput.classList.add(mode);
        });

    </script>
</body>

</html>
